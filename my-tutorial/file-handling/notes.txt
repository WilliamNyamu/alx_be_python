Applications for file manipulation include:
 - Reading data for algorithm training and testing
 - Reading files to create generative art 
 - Reporting
 - Reading configuration files

Files reside in the computer's secondary memory. 
Secondary memory is persistent, which means that data  is not erased when
a computer is powered off.
Once you make changes to a file and save it, the changes are permanently
written and saved in the secondary memory.

To work with files, we need to lead them into the main memory first.
Main memory is the temporary cache memory that holds requested data for a brief interval
The data is lost when the computer is powered off.

Files are loaded from secondary memory to the main memory
and then processed by the CPU. Once the processing is done,
the data is written back to the secondary memory.


How File Handlers work
 When we want to read or write a file, we must open it first.
 Opening a file signals to the operating system to search for the file
 by its name and ensure that it exists.

 The OS returns a file handler if open is successful. Then we can interact
 with our file through the file handler

 The file handler does not contain the data itself, it provides an interface
 for handling the file operations

There are four different methods (modes) for opening a file:

"r" - Read - Default value. Opens a file for reading, error if the file does not exist

"a" - Append - Opens a file for appending, creates the file if it does not exist

"w" - Write - Opens a file for writing, creates the file if it does not exist

"x" - Create - Creates the specified file, returns an error if the file exists

In addition you can specify if the file should be handled as binary or text mode

"t" - Text - Default value. Text mode

"b" - Binary - Binary mode (e.g. images)

It's a good practice to use the with keyword when dealing with file objects.
The advantage is that the file is properly closed after its suite finishes,
even if an exception is raised at some point. Using with is Applicationsmuch shorter than writing
equivalent try-finally blocks:

with open('workfile', encoding="utf-8") as f:
    read_data = f.read()

Python has a set of methods available for the file object.

Method	Description
close()	Closes the file
detach()	Returns the separated raw stream from the buffer
fileno()	Returns a number that represents the stream, from the operating system's perspective
flush()	Flushes the internal buffer
isatty()	Returns whether the file stream is interactive or not
read()	Returns the file content
readable()	Returns whether the file stream can be read or not
readline()	Returns one line from the file
readlines()	Returns a list of lines from the file
seek()	Change the file position
seekable()	Returns whether the file allows us to change the file position
tell()	Returns the current file position
truncate()	Resizes the file to a specified size
writable()	Returns whether the file can be written to or not
write()	Writes the specified string to the file
writelines()	Writes a list of strings to the file